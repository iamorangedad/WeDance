<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Jetson Orin Tracking Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            font-family: monospace;
            font-size: 16px;
            z-index: 10;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="status">连接中...</div>
    <div id="container"></div>

    <script>
        // ================= 配置区域 =================
        const CONFIG = {
            wsUrl: "ws://10.0.0.56:8765", // 修改为 Jetson 的 IP 地址
            lineColor: 0x00ffcc,
            jointColor: 0xffffff,
            lineWidth: 0.8,
            jointSize: 1.2
        };

        const statusDiv = document.getElementById('status');

        // ================= Three.js 初始化 (保持不变) =================
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;
        camera.position.y = 0;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 1, 1);
        scene.add(directionalLight);

        // ================= 骨骼构建逻辑 (保持不变) =================
        const POSE_CONNECTIONS = [
            [0, 1], [0, 2],       // 鼻子到眼睛
            [1, 3], [2, 4],       // 眼睛到耳朵
            [5, 6],               // 双肩连接
            [5, 7], [7, 9],       // 左手: 肩-肘-腕
            [6, 8], [8, 10],      // 右手: 肩-肘-腕
            [5, 11], [6, 12],     // 躯干: 肩到胯
            [11, 12],             // 胯部连接
            [11, 13], [13, 15],   // 左腿: 胯-膝-踝
            [12, 14], [14, 16]    // 右腿: 胯-膝-踝
        ];

        let skeletonMeshes = { joints: [], bones: [] };

        function initSkeletonMesh() {
            for (let i = 0; i < 17; i++) {
                const geometry = new THREE.SphereGeometry(CONFIG.jointSize, 16, 16);
                const material = new THREE.MeshPhongMaterial({ color: CONFIG.jointColor });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.visible = false;
                scene.add(sphere);
                skeletonMeshes.joints.push(sphere);
            }
            POSE_CONNECTIONS.forEach(() => {
                const geometry = new THREE.CylinderGeometry(CONFIG.lineWidth, CONFIG.lineWidth, 1, 8);
                const material = new THREE.MeshPhongMaterial({ color: CONFIG.lineColor, transparent: true, opacity: 0.9 });
                const cylinder = new THREE.Mesh(geometry, material);
                cylinder.visible = false;
                cylinder.geometry.translate(0, 0.5, 0);
                cylinder.geometry.rotateX(Math.PI / 2);
                scene.add(cylinder);
                skeletonMeshes.bones.push(cylinder);
            });
        }
        initSkeletonMesh();

        // ================= WebSocket 数据处理逻辑 =================

        function connectWebSocket() {
            const socket = new WebSocket(CONFIG.wsUrl);

            socket.onopen = () => {
                statusDiv.innerText = "已连接 Jetson Orin";
                statusDiv.style.color = "#00ff00";
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                updateSkeleton(data);
            };

            socket.onclose = () => {
                statusDiv.innerText = "连接断开，尝试重连...";
                statusDiv.style.color = "#ff0000";
                setTimeout(connectWebSocket, 2000);
            };

            socket.onerror = (error) => {
                console.error("WebSocket Error:", error);
            };
        }

        function updateSkeleton(data) {
            if (!data.found || !data.landmarks) {
                // 如果没人，隐藏骨骼
                skeletonMeshes.joints.forEach(m => m.visible = false);
                skeletonMeshes.bones.forEach(m => m.visible = false);
                renderer.render(scene, camera);
                return;
            }

            const landmarks = data.landmarks;
            const scaleX = -30;
            const scaleY = -20;
            const offsetX = 15;
            const offsetY = 10;

            // 1. 更新关节
            landmarks.forEach((landmark, index) => {
                if (index < skeletonMeshes.joints.length) {
                    const mesh = skeletonMeshes.joints[index];

                    const x = (landmark.x * scaleX) + offsetX;
                    const y = (landmark.y * scaleY) + offsetY;
                    // 这是一个简单的伪3D处理：
                    // 如果你想要完全扁平，就设为 0
                    // 或者根据 y 值做一点倾斜，让人看起来是站着的
                    const z = 0;

                    mesh.position.set(x, y, z);
                    mesh.visible = landmark.visibility > 0.5;
                }
            });

            // 2. 更新骨骼连线
            POSE_CONNECTIONS.forEach((pair, index) => {
                if (index < skeletonMeshes.bones.length) {
                    const boneMesh = skeletonMeshes.bones[index];
                    const idx1 = pair[0];
                    const idx2 = pair[1];
                    const joint1 = skeletonMeshes.joints[idx1];
                    const joint2 = skeletonMeshes.joints[idx2];

                    if (joint1.visible && joint2.visible) {
                        boneMesh.visible = true;
                        boneMesh.position.copy(joint1.position);
                        const distance = joint1.position.distanceTo(joint2.position);
                        boneMesh.lookAt(joint2.position);
                        boneMesh.scale.set(1, 1, distance);
                    } else {
                        boneMesh.visible = false;
                    }
                }
            });

            renderer.render(scene, camera);
        }

        // 启动连接
        connectWebSocket();

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

    </script>
</body>

</html>